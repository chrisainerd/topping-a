<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>Wedly — Your Life Style Furniture</title>
  <style>
    :root{
      --panel-bg: rgba(255,255,255,.78);
      --panel-bd: rgba(0,0,0,.12);
      --text:#111; --sub:#444; --accent:#2b6cb0; --shadow:0 8px 28px rgba(0,0,0,.15);
    }
    html, body { margin:0; height:100%; overflow:hidden; background:#ffffff; color:var(--text); }
    canvas { display:block; width:100vw; height:100vh; }

    /* 좌측 상단 툴바 (모드 토글 + 브랜드) */
    #leftTopBar{
      position:fixed; left:12px; top:12px; z-index:40;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .btn {
      border:1px solid var(--panel-bd);
      background:#eef2f7;
      color:#0b1726;
      border-radius:999px;
      padding:6px 10px;
      font-weight:800;
      cursor:pointer;
    }
    .btn.primary { background:#2b6cb0; color:#fff; border-color:#2b6cb0; }
    #brand {
      color:#0b1726; font:12px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,sans-serif;
      background:var(--panel-bg); padding:6px 10px; border-radius:10px;
      border:1px solid var(--panel-bd); backdrop-filter: blur(6px); box-shadow: var(--shadow);
      letter-spacing:.2px;
    }
    #brand .role-badge{
      margin-left:8px; font-weight:800; color:#fff; background:#2b6cb0; padding:2px 6px; border-radius:8px;
      border:1px solid rgba(0,0,0,.15);
    }

    /* 우측 패널(프로 전용) */
    #ui {
      position:fixed; right:12px; top:12px; z-index:30; color:var(--text);
      font:12px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,sans-serif;
      background:var(--panel-bg); width:280px; padding:10px; border-radius:12px;
      border:1px solid var(--panel-bd); box-shadow: var(--shadow); backdrop-filter: blur(8px);
      transition: width .18s ease, padding .18s ease;
      max-height: calc(100vh - 24px); overflow:auto;
    }
    #ui .hdr{ display:flex; align-items:center; justify-content:space-between; margin:0 0 6px; gap:8px; }
    #collapseBtn{ width:22px; height:22px; border-radius:50%; border:1px solid var(--panel-bd);
      background:#f4f7fb; color:#0b1726; cursor:pointer; line-height:20px; font-weight:800; }
    #ui.collapsed{ width:46px; padding:8px; } #ui.collapsed .row{ display:none; }

    .row{ margin-top:8px; }
    label{ display:block; margin-bottom:5px; color:var(--sub); }
    input[type="range"]{ width:100%; }
    .val-badge{ float:right; color:#fff; background:#0b1726; font-weight:700;
      border-radius:10px; padding:0 6px; margin-left:6px; }

    .snap-wrap { position:relative; }
    .snap { display:flex; overflow-x:auto; scroll-snap-type:x mandatory; gap:6px; padding:6px 0; -webkit-overflow-scrolling: touch; }
    .snap::-webkit-scrollbar{ display:none; }
    .snap .item{ flex:0 0 auto; min-width:56px; height:28px; border-radius:14px; padding:0 10px;
      display:flex; align-items:center; justify-content:center; user-select:none; cursor:pointer;
      color:#0b1726; background:#eef2f7; border:1px solid var(--panel-bd); scroll-snap-align:center; font-weight:600; }
    .snap .item.active{ color:#fff; background:#2b6cb0; border-color:#2b6cb0; }
    .snap .ghost{ width:calc(50% - 36px); flex:0 0 auto; }
    .snap-indicator{ position:absolute; left:0; right:0; top:50%; transform:translateY(-50%); pointer-events:none; }
    .snap-indicator::after{ content:""; position:absolute; left:50%; transform:translateX(-50%);
      width:72px; height:32px; border-radius:16px; border:1px dashed rgba(0,0,0,.18); }

    #palette { display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-top:6px; }
    .swatch { width:42px; height:42px; border-radius:10px; border:1px solid var(--panel-bd); cursor:pointer;
      background:#ccc; position:relative; overflow:hidden; box-shadow: 0 2px 10px rgba(0,0,0,.08); }
    .swatch.selected{ outline:2px solid #2b6cb0; outline-offset:2px; }
    .swatch .tag { position:absolute; left:6px; top:6px; font-size:10px; color:#0b1726; font-weight:700;
      background:rgba(255,255,255,.92); border-radius:6px; padding:0 6px; border:1px solid var(--panel-bd); }

    .label{ color:#0b1726; font:11px/1.2 system-ui,sans-serif; background:rgba(255,255,255,.9);
      padding:2px 6px; border-radius:6px; white-space:nowrap; border:1px solid rgba(0,0,0,.15);
      box-shadow:0 2px 10px rgba(0,0,0,.08); }

    /* 역할/표시 제어 */
    .hidden { display:none !important; }
    .disabled { opacity:.45; pointer-events:none; }

    /* 좌측 도크(프로 전용 모바일 프레임) */
    #leftDock{
      position:fixed; left:12px; top:56px; bottom:12px; width:300px; z-index:25;
      display:flex; align-items:center; justify-content:center;
      background:var(--panel-bg); border:1px solid var(--panel-bd); border-radius:14px;
      box-shadow: var(--shadow); backdrop-filter: blur(8px);
    }
    .phone { width: 100%; display:flex; justify-content:center; }
    /* 세로(포트레이트) 고정 */
    .phone .frame{
      width: 280px;
      aspect-ratio: 375 / 667;
      height: auto;
      border:12px solid #222; border-bottom-width:16px; border-top-width:16px;
      border-radius:26px; box-shadow:0 10px 28px rgba(0,0,0,.25); background:#000; overflow:hidden; position:relative;
    }
    .phone .toolbar{ position:absolute; left:8px; top:8px; right:8px; display:flex; gap:6px; z-index:2; }
    .phone .toolbar button{ font-size:11px; padding:4px 8px; }
    iframe.mobile { width:100%; height:100%; border:0; background:#fff; }

    /* 좌측 하단 견적 HUD */
    #quoteHUD{
      position:fixed; left:12px; bottom:12px; z-index:50;
      background:rgba(0,0,0,.75); color:#fff; padding:12px 14px; border-radius:12px;
      border:1px solid rgba(255,255,255,.2); backdrop-filter: blur(6px);
      box-shadow: 0 10px 28px rgba(0,0,0,.3);
      display:flex; align-items:center; gap:10px;
    }
    #quoteHUD .price{ font-weight:900; font-size:22px; letter-spacing:.2px; }
    #quoteHUD .note{ font-size:11px; opacity:.8; }
    #downloadPDF.btn{ background:#10b981; color:#072518; border-color:#0ea37d; }

    /* embed 모드에서 UI 숨김 */
    .embed-hide { display:none !important; }
  </style>

  <script src="/socket.io/socket.io.js"></script>
  <!-- three.js r124 (UMD) + OrbitControls + CSS2DRenderer -->
  <script src="https://unpkg.com/three@0.124.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.124.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.124.0/examples/js/renderers/CSS2DRenderer.js"></script>
  <!-- PDF 생성용(jsPDF) -->
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
  <!-- 좌측 상단 툴바 (모드 토글 + 브랜드) -->
  <div id="leftTopBar">
    <button id="toggleRole" class="btn primary" aria-label="프로/고객 전환">프로 모드</button>
    <div id="brand">Wedly — Your Life Style Furniture <span id="roleBadge" class="role-badge" style="display:none"></span></div>
  </div>

  <!-- 좌측 도크(프로 전용: 고객 모바일 프레임) -->
  <div id="leftDock" class="hidden">
    <div class="phone">
      <div class="frame">
        <div class="toolbar">
          <button class="btn" id="refreshPreview">새로고침</button>
          <button class="btn" id="openStandalone">새 탭</button>
        </div>
        <iframe id="mobileFrame" class="mobile" title="모바일 미리보기"></iframe>
      </div>
    </div>
  </div>

  <!-- 우측 패널(프로에서만 보임) -->
  <div id="ui">
    <div class="hdr">
      <div style="font-weight:700;color:#0b1726;">설계 파라미터</div>
      <button id="collapseBtn" aria-label="패널 접기">▾</button>
    </div>

    <!-- 치수/깊이/두께 -->
    <div class="row" id="rowW">
      <label>가로 (W) <span id="wVal" class="val-badge">1200 mm</span></label>
      <input id="w" type="range" min="40" max="240" step="1" value="120">
    </div>
    <div class="row" id="rowH">
      <label>세로 (H) <span id="hVal" class="val-badge">1800 mm</span></label>
      <input id="h" type="range" min="60" max="240" step="1" value="180">
    </div>
    <div class="row" id="rowDepth">
      <label>깊이 (D)</label>
      <div class="snap-wrap">
        <div id="depthPicker" class="snap"></div>
        <div class="snap-indicator"></div>
      </div>
    </div>
    <div class="row" id="rowThick">
      <label>판 두께</label>
      <div class="snap-wrap">
        <div id="thickPicker" class="snap"></div>
        <div class="snap-indicator"></div>
      </div>
    </div>

    <div class="row">
      <label>선반 수 (행) <span id="rowsVal" class="val-badge">4</span></label>
      <input id="rows" type="range" min="1" max="10" step="1" value="4">
    </div>
    <div class="row">
      <label>칸 수 (열) <span id="colsVal" class="val-badge">3</span></label>
      <input id="cols" type="range" min="1" max="8" step="1" value="3">
    </div>

    <div class="row">
      <label>팔레트 (패널+엣지)</label>
      <div id="palette"></div>
    </div>

    <!-- 문/서랍 -->
    <div class="row">
      <label style="display:flex;justify-content:space-between;align-items:center;">
        문 사용
        <input id="doorEnable" type="checkbox" checked>
      </label>
    </div>
    <div class="row" id="doorAngleRow">
      <label>문 열림 각도 <span id="doorVal" class="val-badge">0°</span></label>
      <input id="doorAngle" type="range" min="0" max="110" step="1" value="0">
    </div>
    <div class="row">
      <label style="display:flex;justify-content:space-between;align-items:center;">
        서랍 사용
        <input id="drawerEnable" type="checkbox">
      </label>
    </div>
    <div class="row" id="drawerCountRow" style="display:none">
      <label>서랍 개수 <span id="drawerCountVal" class="val-badge">3</span></label>
      <input id="drawerCount" type="range" min="1" max="6" step="1" value="3">
    </div>
  </div>

  <!-- 좌측 하단 견적 HUD -->
  <div id="quoteHUD">
    <div class="price" id="quotePrice">₩-</div>
    <button id="downloadPDF" class="btn">견적서(PDF) 다운로드</button>
    <div class="note">※ 견적 산식은 데모입니다</div>
  </div>

  <canvas id="c"></canvas>

  <script>
    // ==== 역할/임베드 감지 ====
    const urlParams = new URLSearchParams(location.search);
    const roleFromUrl = urlParams.get('role');
    const roleFromLS  = localStorage.getItem('role');
    let ROLE = (roleFromUrl || roleFromLS || 'pro').toLowerCase()==='customer' ? 'customer' : 'pro';
    localStorage.setItem('role', ROLE);

    const EMBED = (urlParams.get('embed') === '1');

    // 소켓
    const socket = io();

    // 렌더러/그림자
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;

    // CSS2D
    const labelRenderer = new THREE.CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position='fixed';
    labelRenderer.domElement.style.left='0'; labelRenderer.domElement.style.top='0';
    labelRenderer.domElement.style.pointerEvents='none';
    document.body.appendChild(labelRenderer.domElement);

    // 씬/카메라/조명
    const scene = new THREE.Scene(); scene.background = new THREE.Color(0xffffff);
    const camera = new THREE.PerspectiveCamera(60, 2, 0.1, 100);
    camera.position.set(2.8,2.0,3.2);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.85);
    dir.position.set(3,6,4);
    dir.castShadow = true; dir.shadow.mapSize.set(1024,1024);
    dir.shadow.radius = 4; dir.shadow.bias = -0.0005; dir.shadow.normalBias = 0.02;
    scene.add(dir); scene.add(dir.target);

    function onResize(){ const w=window.innerWidth,h=window.innerHeight;
      renderer.setSize(w,h,false); labelRenderer.setSize(w,h);
      camera.aspect=w/h; camera.updateProjectionMatrix(); }
    window.addEventListener('resize', onResize); onResize();

    // 팔레트
    const palettes = [
      { id:'safe_navybeige',       name:'Navy & Beige',        type:'Safe',    base:'#E6D8C3', edge:'#2B3A67' },
      { id:'safe_greige_charcoal', name:'Greige & Charcoal',   type:'Safe',    base:'#E6E2D9', edge:'#333333' },
      { id:'safe_sage_offwhite',   name:'Sage & Offwhite',     type:'Safe',    base:'#9BB69B', edge:'#F5F3EE' },
      { id:'safe_charcoal_offwhite', name:'Charcoal & Offwhite', type:'Safe',  base:'#2F3B45', edge:'#F5F5F5' },
      { id:'icon_tiffany', name:'Tiffany Blue & White', type:'Iconic', base:'#81D8D0', edge:'#FFFFFF' },
      { id:'icon_coca',    name:'Coca-Cola Red & White', type:'Iconic', base:'#F40009', edge:'#FFFFFF' },
      { id:'icon_ikea',    name:'IKEA Blue & Yellow',   type:'Iconic', base:'#0058A3', edge:'#FFCC00' },
      { id:'mondrian_bw',  name:'Mondrian Grid',        type:'Mondrian', base:'#F5F5F5', edge:'#111111' },
    ];

    // 파라미터
    const params = {
      w:120, h:180, d:400, t:18, rows:4, cols:3,
      scheme:'safe_greige_charcoal', color:'#E6E2D9', edgeColor:'#333333',
      door:{ enabled:true, angleL:0, angleR:0 },
      drawers:{ enabled:false, count:3 }
    };

    // 재질
    const panelMat = new THREE.MeshStandardMaterial({ color: params.color, roughness:0.6, metalness:0.05 });
    const edgeMat  = new THREE.MeshStandardMaterial({ color: params.edgeColor, roughness:0.45, metalness:0.1 });

    // 그룹
    const modelRoot = new THREE.Group(); scene.add(modelRoot);
    const dimsRoot  = new THREE.Group(); scene.add(dimsRoot);
    const envRoot   = new THREE.Group(); scene.add(envRoot);

    const cm=(v)=>v/100, mm=(v)=>v/1000;
    function clearGroup(g){ while(g.children.length) g.remove(g.children[0]); }

    // ==== 견적 계산(실시간) ====
    const KRW = (n)=> '₩' + (Math.round(n).toLocaleString('ko-KR'));
    function computeQuote(p){
      // 산식(데모) — 필요 시 수정
      const w_m = p.w/100; const h_m = p.h/100; const d_m = p.d/1000;
      const frontArea = w_m * h_m;
      const BASE = 150000;
      const AREA_RATE = 120000;    // m²당
      const DEPTH_RATE = 80000;    // m당
      const THICK_FACTOR = (p.t>=24) ? 1.10 : 1.00;
      const DOOR_OPT = (p.door && p.door.enabled) ? 40000 : 0;
      const DRAWER_OPT = (p.drawers && p.drawers.enabled) ? (p.drawers.count * 30000) : 0;
      let price = BASE + (frontArea*AREA_RATE) + (d_m*DEPTH_RATE) + DOOR_OPT + DRAWER_OPT;
      price *= THICK_FACTOR;
      const scheme = p.scheme || '';
      if (scheme.startsWith('icon_')) price *= 1.05;
      if (scheme.startsWith('mondrian_')) price *= 1.08;
      return Math.round(price/100)*100;
    }
    function updateQuoteHUD(){
      document.getElementById('quotePrice').textContent = KRW(computeQuote(params));
    }

    // 패널 + 엣지(앞면 1mm 라미나)
    function panelWithEdge(sx, sy, sz, px, py, pz, addEdge=true){
      const matP = panelMat.clone();
      const panel = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), matP);
      panel.position.set(px,py,pz);
      panel.castShadow = true; panel.receiveShadow = true; modelRoot.add(panel);
      if(addEdge){
        const edgeDepth = mm(1.0), eps=0.0001;
        const edge = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,edgeDepth), edgeMat.clone());
        edge.position.set(px,py,pz + sz/2 + edgeDepth/2 + eps);
        edge.castShadow = true; edge.receiveShadow = true; modelRoot.add(edge);
      }
    }

    // 문 둘레 엣지 밴딩
    function addDoorPerimeterEdges(pivot, doorCenterX, doorW, doorH, doorT){
      const ed = mm(1.0), zExpand = 0.0004, mat = edgeMat.clone();
      const g = new THREE.Group(); g.position.set(doorCenterX, 0, 0); pivot.add(g);
      const depthZ = doorT + zExpand;
      const left  = new THREE.Mesh(new THREE.BoxGeometry(ed, doorH, depthZ), mat);
      const right = new THREE.Mesh(new THREE.BoxGeometry(ed, doorH, depthZ), mat);
      left.position.set(-doorW/2 - ed/2, 0, 0);
      right.position.set( doorW/2 + ed/2, 0, 0);
      const cover = ed*2;
      const top    = new THREE.Mesh(new THREE.BoxGeometry(doorW + cover, ed, depthZ), mat);
      const bottom = new THREE.Mesh(new THREE.BoxGeometry(doorW + cover, ed, depthZ), mat);
      top.position.set(0,  doorH/2 + ed/2, 0);
      bottom.position.set(0, -doorH/2 - ed/2, 0);
      [left,right,top,bottom].forEach(m=>{ m.castShadow = true; m.receiveShadow = true; g.add(m); });
    }

    // 문 피벗/보간
    let doorPivots = { left:null, right:null };
    let curDoorL=0, curDoorR=0, targetDoorL=0, targetDoorR=0;
    function applyDoorAngles(degL,degR,snap=false){
      targetDoorL = THREE.MathUtils.degToRad(-degL);
      targetDoorR = THREE.MathUtils.degToRad(degR);
      if(snap){
        curDoorL=targetDoorL; curDoorR=targetDoorR;
        if(doorPivots.left)  doorPivots.left.rotation.y  = curDoorL;
        if(doorPivots.right) doorPivots.right.rotation.y = curDoorR;
      }
    }

    function buildDoors(p){
      if(!p.door || !p.door.enabled){ doorPivots={left:null,right:null}; return; }
      const W=cm(p.w), H=cm(p.h), D=mm(p.d), T=mm(p.t);
      const gapC=0.002, hingeGap=0.001;
      const doorT = Math.max(0.016, T);
      const innerW=W-2*T, innerH=H-2*T;
      const doorW = innerW/2 - gapC/2 - hingeGap;
      const zFront = D/2 + doorT/2 + 0.0005;

      // 왼쪽
      const leftPivot = new THREE.Group();
      leftPivot.position.set(-W/2 + T, 0, zFront); modelRoot.add(leftPivot);
      const leftDoor = new THREE.Mesh(new THREE.BoxGeometry(doorW, innerH, doorT), panelMat.clone());
      leftDoor.castShadow=true; leftDoor.receiveShadow=true;
      leftDoor.position.set(doorW/2 + hingeGap, 0, 0); leftPivot.add(leftDoor);
      addDoorPerimeterEdges(leftPivot,  doorW/2 + hingeGap, doorW, innerH, doorT);

      // 오른쪽
      const rightPivot = new THREE.Group();
      rightPivot.position.set(W/2 - T, 0, zFront); modelRoot.add(rightPivot);
      const rightDoor = new THREE.Mesh(new THREE.BoxGeometry(doorW, innerH, doorT), panelMat.clone());
      rightDoor.castShadow=true; rightDoor.receiveShadow=true;
      rightDoor.position.set(-doorW/2 - hingeGap, 0, 0); rightPivot.add(rightDoor);
      addDoorPerimeterEdges(rightPivot, -doorW/2 - hingeGap, doorW, innerH, doorT);

      doorPivots.left = leftPivot; doorPivots.right = rightPivot;
      applyDoorAngles(p.door.angleL, p.door.angleR, true);
    }

    // 서랍 레이아웃/생성
    function computeDrawerLayout(p){
      if(!p.drawers || !p.drawers.enabled || p.drawers.count<=0) return null;
      const W=cm(p.w), H=cm(p.h), D=mm(p.d), T=mm(p.t), count=Math.max(1, Math.floor(p.drawers.count));
      const faceT=Math.max(0.016, T), gapY=0.003, insetX=0.002;
      const innerW=W-2*T - insetX*2, innerH=H-2*T;

      const minFaceH=0.06;
      const totalGap = gapY*(count+1);
      const faceH = Math.max(minFaceH, (innerH - totalGap) / count);

      const zFront = (params.door && params.door.enabled) ? (D/2 - faceT/2 - 0.001) : (D/2 + faceT/2 + 0.0005);
      const y0 = -H/2 + T + gapY + faceH/2;
      const yTop = y0 + (count-1)*(faceH+gapY) + faceH/2;

      return { W,H,D,T,count,faceT,gapY,insetX,innerW,innerH,faceH,zFront,y0,yTop };
    }
    function buildDrawers(layout){
      if(!layout) return;
      const matFace = panelMat.clone();
      const matHandle = new THREE.MeshStandardMaterial({ color:0x111111, metalness:0.6, roughness:0.35 });
      let y = layout.y0;
      for(let i=0;i<layout.count;i++){
        const face = new THREE.Mesh(new THREE.BoxGeometry(layout.innerW, layout.faceH, layout.faceT), matFace);
        face.castShadow=true; face.receiveShadow=true;
        face.position.set(0,y,layout.zFront); modelRoot.add(face);

        const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.006,0.006,0.09,16), matHandle);
        handle.rotation.z = Math.PI/2;
        handle.position.set(0, y + layout.faceH*0.15, layout.zFront + layout.faceT/2 + 0.008);
        handle.castShadow=true; modelRoot.add(handle);

        y += layout.faceH + layout.gapY;
      }
    }

    // 치수(mm)
    function updateDimensions(p){
      clearGroup(dimsRoot);
      const W=cm(p.w), H=cm(p.h), D=mm(p.d);
      const off=mm(80), tip=mm(24);
      const lineMat=new THREE.LineBasicMaterial({ color:0x222222 });
      const makeLine=(pts)=> new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), lineMat);
      function addDimension(A,B,text,pos){
        dimsRoot.add(makeLine([A,B]));
        const dir=new THREE.Vector3().subVectors(B,A).normalize();
        let perp=new THREE.Vector3().crossVectors(dir,new THREE.Vector3(0,1,0));
        if(perp.lengthSq()<1e-6) perp.set(1,0,0); else perp.normalize();
        const a1=A.clone().add(dir.clone().multiplyScalar(tip));
        dimsRoot.add(makeLine([A,a1.clone().add(perp.clone().multiplyScalar( tip*0.4))]));
        dimsRoot.add(makeLine([A,a1.clone().add(perp.clone().multiplyScalar(-tip*0.4))]));
        const b1=B.clone().add(dir.clone().multiplyScalar(-tip));
        dimsRoot.add(makeLine([B,b1.clone().add(perp.clone().multiplyScalar( tip*0.4))]));
        dimsRoot.add(makeLine([B,b1.clone().add(perp.clone().multiplyScalar(-tip*0.4))]));
        const div=document.createElement('div'); div.className='label'; div.textContent=text;
        const label=new THREE.CSS2DObject(div); label.position.copy(pos); dimsRoot.add(label);
      }
      const Wmm=Math.round(p.w*10), Hmm=Math.round(p.h*10), Dmm=Math.round(p.d);
      const A_w=new THREE.Vector3(-W/2,-H/2-mm(60), D/2+off);
      const B_w=new THREE.Vector3( W/2,-H/2-mm(60), D/2+off);
      addDimension(A_w,B_w,`${Wmm} mm`, A_w.clone().add(B_w).multiplyScalar(0.5).add(new THREE.Vector3(0,mm(26),0)));
      const A_h=new THREE.Vector3(W/2+off,-H/2, D/2);
      const B_h=new THREE.Vector3(W/2+off, H/2, D/2);
      addDimension(A_h,B_h,`${Hmm} mm`, A_h.clone().add(B_h).multiplyScalar(0.5).add(new THREE.Vector3(0,0,mm(26))));
      const A_d=new THREE.Vector3(W/2+off,-H/2-mm(60), D/2);
      const B_d=new THREE.Vector3(W/2+off,-H/2-mm(60),-D/2);
      addDimension(A_d,B_d,`${Dmm} mm`, A_d.clone().add(B_d).multiplyScalar(0.5).add(new THREE.Vector3(0,mm(24),0)));
    }

    // ===== 벽/바닥 색/진하기 조정 지점 =====
    const WALL_COLOR_HEX = 0xE5E7EB; // 벽 색상(연한 회색)
    const FLOOR_GRADIENT = ['#2b2f36','#32363d','#3a3f45']; // 바닥 그라데이션(진한 회색)

    function makeGradientFloor(size, center, y){
      const c=document.createElement('canvas'); c.width=2; c.height=512;
      const g=c.getContext('2d'); const grad=g.createLinearGradient(0,0,0,c.height);
      grad.addColorStop(0.00, FLOOR_GRADIENT[0]);
      grad.addColorStop(0.40, FLOOR_GRADIENT[1]);
      grad.addColorStop(1.00, FLOOR_GRADIENT[2]);
      g.fillStyle=grad; g.fillRect(0,0,c.width,c.height);
      const tex=new THREE.CanvasTexture(c); tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
      tex.wrapS=THREE.ClampToEdgeWrapping; tex.wrapT=THREE.ClampToEdgeWrapping; tex.flipY=false;
      const geo=new THREE.PlaneGeometry(size,size);
      const mat=new THREE.MeshStandardMaterial({ map:tex, roughness:0.96, metalness:0.0 });
      const floor=new THREE.Mesh(geo,mat); floor.rotation.x=-Math.PI/2; floor.position.set(center.x,y,center.z); floor.receiveShadow=true; return floor;
    }

    function updateEnvironment(){
      clearGroup(envRoot);
      const box=new THREE.Box3().setFromObject(modelRoot);
      if(!isFinite(box.min.x)||!isFinite(box.max.x)) return;
      const size=new THREE.Vector3(); box.getSize(size);
      const center=new THREE.Vector3(); box.getCenter(center);

      const wallH=Math.max(2.4,size.y*1.4)*10;
      const wallLen=Math.max(6,Math.max(size.x,size.z)*2.2)*10;
      const wallMat=new THREE.MeshStandardMaterial({ color:WALL_COLOR_HEX, roughness:0.95, metalness:0.0 });
      const backWall=new THREE.Mesh(new THREE.PlaneGeometry(wallLen,wallH), wallMat);
      const EPS_Z=0.0015, gap=mm(params.t+5);
      backWall.position.set(center.x, box.min.y+wallH/2, box.min.z - gap - EPS_Z);
      backWall.receiveShadow=true; envRoot.add(backWall);

      const floorSize = wallLen * 1.1;
      const floorY=box.min.y - mm(0.5);
      envRoot.add(makeGradientFloor(floorSize, center, floorY));

      dir.target.position.copy(center);
      dir.position.copy(center.clone().add(new THREE.Vector3(3,6,4)));
    }

    function tuneShadowCamera(){
      const box=new THREE.Box3().setFromObject(modelRoot);
      if(!isFinite(box.min.x)||!isFinite(box.max.x)) return;
      const size=new THREE.Vector3(); box.getSize(size);
      const extent=Math.max(size.x,size.y,size.z)*1.2+1.5;
      const cam=dir.shadow.camera;
      cam.left=-extent; cam.right=extent; cam.top=extent; cam.bottom=-extent;
      cam.near=0.1; cam.far=extent*3.0; cam.updateProjectionMatrix();
    }

    // UI refs
    const ui={
      root:document.getElementById('ui'), collapseBtn:document.getElementById('collapseBtn'),
      w:document.getElementById('w'), h:document.getElementById('h'),
      wVal:document.getElementById('wVal'), hVal:document.getElementById('hVal'),
      rows:document.getElementById('rows'), cols:document.getElementById('cols'),
      rowsVal:document.getElementById('rowsVal'), colsVal:document.getElementById('colsVal'),
      depthPicker:document.getElementById('depthPicker'), thickPicker:document.getElementById('thickPicker'),
      palette:document.getElementById('palette'),
      doorEnable:document.getElementById('doorEnable'), doorAngle:document.getElementById('doorAngle'),
      doorVal:document.getElementById('doorVal'), doorAngleRow:document.getElementById('doorAngleRow'),
      drawerEnable:document.getElementById('drawerEnable'), drawerCount:document.getElementById('drawerCount'),
      drawerCountVal:document.getElementById('drawerCountVal'), drawerCountRow:document.getElementById('drawerCountRow'),
      roleBadge:document.getElementById('roleBadge'),
      toggleRole:document.getElementById('toggleRole'),

      leftDock:document.getElementById('leftDock'),
      mobileFrame:document.getElementById('mobileFrame'),
      refreshPreview:document.getElementById('refreshPreview'),
      openStandalone:document.getElementById('openStandalone'),

      quotePrice:document.getElementById('quotePrice'),
      downloadPDF:document.getElementById('downloadPDF')
    };

    if (EMBED) {
      document.getElementById('leftTopBar').classList.add('embed-hide');
      ui.root.classList.add('embed-hide');
      document.getElementById('leftDock').classList.add('embed-hide');
      document.getElementById('quoteHUD').classList.add('embed-hide');
    }

    const LS_KEY='uiCollapsed';
    function applyCollapsedState(c){ ui.root.classList.toggle('collapsed',c);
      ui.collapseBtn.textContent=c?'▸':'▾'; localStorage.setItem(LS_KEY,c?'1':'0'); }
    applyCollapsedState(localStorage.getItem(LS_KEY)==='1');
    ui.collapseBtn.addEventListener('click',()=> applyCollapsedState(!ui.root.classList.contains('collapsed')));

    function renderPalette(selectedId){
      ui.palette.innerHTML=''; palettes.forEach(p=>{
        const div=document.createElement('div'); div.className='swatch';
        if(p.id===selectedId) div.classList.add('selected');
        div.style.background=p.base; div.title=`${p.name} (${p.type})`;
        const tri=document.createElement('div'); tri.style.cssText='position:absolute;right:0;bottom:0;width:0;height:0;border-left:22px solid transparent;border-top:22px solid transparent;';
        tri.style.borderRight=`22px solid ${p.edge}`; tri.style.borderBottom=`22px solid ${p.edge}`; tri.style.opacity='0.95'; div.appendChild(tri);
        const tag=document.createElement('div'); tag.className='tag';
        tag.textContent = ({Safe:'S', Iconic:'I', Mondrian:'M'})[p.type] || p.type[0];
        div.appendChild(tag);
        div.addEventListener('click',()=>{
          params.scheme=p.id; params.color=p.base; params.edgeColor=p.edge;
          panelMat.color.set(params.color); edgeMat.color.set(params.edgeColor);
          buildShelf(params); sendParams(); updateQuoteHUD();
        });
        ui.palette.appendChild(div);
      });
    }
    renderPalette(params.scheme);

    function makeSnapPicker(el, values, initial, onChange){
      el.innerHTML=''; const ghostL=document.createElement('div'); ghostL.className='ghost';
      const ghostR=document.createElement('div'); ghostR.className='ghost'; el.appendChild(ghostL);
      values.forEach(v=>{ const b=document.createElement('div'); b.className='item'; b.textContent=v; b.dataset.value=v; el.appendChild(b); });
      el.appendChild(ghostR);
      function centerOn(value,smooth=true){
        const items=[...el.querySelectorAll('.item')];
        const t=items.find(i=>String(i.dataset.value)===String(value))||items[0];
        t.scrollIntoView({behavior:smooth?'smooth':'auto', inline:'center', block:'nearest'});
        items.forEach(i=>i.classList.toggle('active', i===t));
      }
      let timer; el.addEventListener('scroll',()=>{ clearTimeout(timer); timer=setTimeout(()=>{
        const mid=el.scrollLeft + el.clientWidth/2; const items=[...el.querySelectorAll('.item')];
        let best=null, bestDist=Infinity; items.forEach(i=>{ const r=i.getBoundingClientRect();
          const center=r.left + r.width/2 + el.scrollLeft - el.getBoundingClientRect().left; const d=Math.abs(center-mid);
          if(d<bestDist){ bestDist=d; best=i; } }); if(best){ items.forEach(i=>i.classList.toggle('active', i===best)); onChange(best.dataset.value); }
      },80); }, {passive:true});
      el.addEventListener('click',(e)=>{ const it=e.target.closest('.item'); if(!it) return; centerOn(it.dataset.value); onChange(it.dataset.value); });
      centerOn(initial,false); return { centerOn };
    }
    const depthValues=[300,400,500,600], thickValues=[18,24];
    const depthPicker=makeSnapPicker(document.getElementById('depthPicker'), depthValues, params.d, (v)=>{ params.d=parseInt(v,10); buildShelf(params); sendParams(); updateQuoteHUD(); });
    const thickPicker=makeSnapPicker(document.getElementById('thickPicker'), thickValues, params.t, (v)=>{ params.t=parseInt(v,10); buildShelf(params); sendParams(); updateQuoteHUD(); });

    function updateBadges(){
      ui.wVal.textContent=`${Math.round(params.w*10)} mm`;
      ui.hVal.textContent=`${Math.round(params.h*10)} mm`;
      ui.rowsVal.textContent=`${params.rows}`; ui.colsVal.textContent=`${params.cols}`;
      ui.doorVal.textContent=`${Math.round(params.door.angleL)}°`; ui.doorAngle.value=params.door.angleL;
      ui.doorEnable.checked=!!params.door.enabled;
      ui.doorAngleRow.style.opacity=params.door.enabled?1:0.4; ui.doorAngle.disabled=!params.door.enabled;
      ui.drawerEnable.checked=!!params.drawers.enabled;
      ui.drawerCountRow.style.display=params.drawers.enabled?'':'none';
      ui.drawerCount.value=params.drawers.count; ui.drawerCountVal.textContent=`${params.drawers.count}`;
    }

    function sendParams(){ if(applyingRemote) return; socket.emit("syncState",{ params }); }

    function onWHInput(){ params.w=parseFloat(ui.w.value); params.h=parseFloat(ui.h.value);
      updateBadges(); buildShelf(params); sendParams(); updateQuoteHUD(); }
    document.getElementById('w').addEventListener('input', onWHInput);
    document.getElementById('h').addEventListener('input', onWHInput);

    function onWHRelease(){ if(!applyingRemote) autoFrameBothTween(0.6,350); }
    document.getElementById('w').addEventListener('change', onWHRelease);
    document.getElementById('h').addEventListener('change', onWHRelease);
    document.getElementById('w').addEventListener('pointerup', onWHRelease);
    document.getElementById('h').addEventListener('pointerup', onWHRelease);

    function onRowsColsChange(){ params.rows=parseInt(ui.rows.value,10);
      params.cols=parseInt(ui.cols.value,10); updateBadges(); buildShelf(params); sendParams(); updateQuoteHUD(); }
    ui.rows.addEventListener('input', onRowsColsChange); ui.cols.addEventListener('input', onRowsColsChange);

    ui.doorEnable.addEventListener('change', ()=>{
      params.door.enabled = ui.doorEnable.checked;
      ui.doorAngleRow.style.opacity = params.door.enabled?1:0.4;
      ui.doorAngle.disabled = !params.door.enabled;
      buildShelf(params); sendParams(); updateQuoteHUD();
    });
    ui.doorAngle.addEventListener('input', ()=>{
      const v=parseInt(ui.doorAngle.value,10);
      params.door.angleL=params.door.angleR=v;
      ui.doorVal.textContent=`${v}°`;
      applyDoorAngles(params.door.angleL, params.door.angleR);
      sendParams();
    });
    ui.drawerEnable.addEventListener('change', ()=>{
      params.drawers.enabled = ui.drawerEnable.checked;
      ui.drawerCountRow.style.display = params.drawers.enabled?'':'none';
      buildShelf(params); sendParams(); updateQuoteHUD();
    });
    ui.drawerCount.addEventListener('input', ()=>{
      params.drawers.count = parseInt(ui.drawerCount.value,10);
      ui.drawerCountVal.textContent = `${params.drawers.count}`;
      buildShelf(params); sendParams(); updateQuoteHUD();
    });

    // ===== 프로/고객 토글 =====
    function applyRoleMode(){
      const isCustomer = (ROLE === 'customer');
      ui.roleBadge.style.display='inline-block';
      ui.roleBadge.textContent = isCustomer ? 'CUSTOMER' : 'PRO';
      ui.root.style.display = isCustomer ? 'none' : '';
      document.getElementById('leftDock').classList.toggle('hidden', isCustomer);
      ui.toggleRole.textContent = isCustomer ? '고객 모드' : '프로 모드';
    }
    function setMobilePreviewSrc(){
      const base = new URL(location.href);
      base.searchParams.set('role','customer');
      base.searchParams.set('embed','1');
      ui.mobileFrame.src = base.toString();
    }
    ui.toggleRole.addEventListener('click', ()=>{
      ROLE = (ROLE === 'pro') ? 'customer' : 'pro';
      localStorage.setItem('role', ROLE);
      const next = new URL(location.href);
      next.searchParams.set('role', ROLE);
      if (ROLE === 'pro') next.searchParams.delete('embed');
      location.href = next.toString();
    });
    document.getElementById('refreshPreview').addEventListener('click', setMobilePreviewSrc);
    document.getElementById('openStandalone').addEventListener('click', ()=>{
      const base = new URL(location.href);
      base.searchParams.set('role','customer'); base.searchParams.delete('embed');
      window.open(base.toString(), '_blank');
    });

    // === [NEW] PDF 한글 폰트 로더 ===
    // /fonts/NanumGothic-Regular.ttf 파일을 프로젝트에 추가해 주세요.
    function ab2b64(buf){
      let binary = '';
      const bytes = new Uint8Array(buf);
      const chunk = 0x8000; // chunk to avoid call stack overflow
      for (let i=0; i<bytes.length; i+=chunk){
        const sub = bytes.subarray(i, i+chunk);
        binary += String.fromCharCode.apply(null, sub);
      }
      return btoa(binary);
    }
    async function loadKoreanFont(doc){
      const url = '/fonts/NanumGothic-Regular.ttf';
      try{
        const res = await fetch(url);
        if(!res.ok) throw new Error('폰트 응답 실패');
        const buf = await res.arrayBuffer();
        const b64 = ab2b64(buf);
        const fontFile = 'NanumGothic-Regular.ttf';
        const fontName = 'NanumGothic';
        doc.addFileToVFS(fontFile, b64);
        doc.addFont(fontFile, fontName, 'normal');
        return fontName;
      }catch(e){
        console.warn('[PDF] 한글 폰트 로드 실패:', e);
        return null;
      }
    }

    // ===== PDF 다운로드 (한글 폰트 임베드) =====
    document.getElementById('downloadPDF').addEventListener('click', async ()=>{
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit:'pt', format:'a4' });

      // 1) 한글 폰트 로드 & 적용
      const fontName = await loadKoreanFont(doc);
      if (fontName){
        doc.setFont(fontName, 'normal');
      } else {
        alert('한글 폰트를 찾을 수 없어 기본 폰트로 생성합니다. (한글이 깨질 수 있어요)\n/fonts/NanumGothic-Regular.ttf 를 추가해 주세요.');
        // fallback: 기본 폰트(헬베티카)는 한글 미지원
      }

      const margin = 48;
      const lineH = 18;
      let y = margin;

      // 제목 (굵기 대신 크기/라인 강조)
      doc.setFontSize(22);
      doc.text('견적서', margin, y); y += 10;
      doc.setDrawColor(30); doc.setLineWidth(0.8);
      doc.line(margin, y, 595-margin, y); y += 24;

      // 견적 금액
      doc.setFontSize(16);
      doc.setTextColor(20,120,20);
      const priceText = KRW(computeQuote(params));
      doc.text(`총 예상가: ${priceText}`, margin, y); y += 24;

      // 스펙
      doc.setTextColor(0,0,0);
      doc.setFontSize(12);
      const spec = [
        `크기: ${Math.round(params.w*10)} x ${Math.round(params.h*10)} x ${Math.round(params.d)} mm (T${params.t})`,
        `격자: ${params.rows}행 x ${params.cols}열`,
        `문: ${params.door.enabled ? '사용' : '미사용'}  /  서랍: ${params.drawers.enabled ? (params.drawers.count+'개') : '없음'}`,
        `팔레트: ${params.scheme}`,
        `참고: 견적 산식은 데모입니다(실제 계약 전 확정 필요)`
      ];
      spec.forEach(t=>{ doc.text(t, margin, y); y += lineH; });

      // 꼬리말
      y += 12;
      doc.setFontSize(10); doc.setTextColor(90);
      doc.text(`생성 시각: ${new Date().toLocaleString('ko-KR')}`, margin, y);

      doc.save(`wedly-quote-${Date.now()}.pdf`);
    });

    // 카메라 동기화
    let applyingRemote=false, lastSend=0; const SEND_MS=33;
    function sendCamera(){ if(applyingRemote) return; const now=performance.now(); if(now-lastSend<SEND_MS) return; lastSend=now;
      socket.emit("syncState",{
        camPos:{x:camera.position.x,y:camera.position.y,z:camera.position.z},
        camQuat:{x:camera.quaternion.x,y:camera.quaternion.y,z:camera.quaternion.z,w:camera.quaternion.w},
        camZoom:camera.zoom, target:{x:controls.target.x,y:controls.target.y,z:controls.target.z}
      });
    }
    controls.addEventListener('change', sendCamera);

    // 핑 + 소리
    const raycaster=new THREE.Raycaster(), pointer=new THREE.Vector2(), pings=[];
    const MAX_PINGS=12, PING_DURATION=900;
    let audioCtx=null, audioReady=false;
    function ensureAudio(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); audioReady=true; }
    window.addEventListener('pointerdown', ensureAudio, {once:true});
    function playPing(vol=0.25, baseHz=920){
      if(!audioReady||!audioCtx) return; const t0=audioCtx.currentTime;
      const g=audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t0);
      g.gain.linearRampToValueAtTime(vol,t0+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t0+0.26);
      const biq=audioCtx.createBiquadFilter(); biq.type='bandpass'; biq.frequency.setValueAtTime(1800,t0); biq.Q.setValueAtTime(3,t0);
      const o1=audioCtx.createOscillator(); o1.type='sine'; o1.frequency.setValueAtTime(baseHz*0.98,t0); o1.frequency.linearRampToValueAtTime(baseHz,t0+0.12);
      const o2=audioCtx.createOscillator(); o2.type='triangle'; o2.frequency.setValueAtTime(baseHz*1.5,t0); o2.frequency.linearRampToValueAtTime(baseHz*1.6,t0+0.12);
      o1.connect(biq); o2.connect(biq); biq.connect(g); g.connect(audioCtx.destination); o1.start(t0); o2.start(t0); o1.stop(t0+0.28); o2.stop(t0+0.28);
    }
    function createPing(pos, normal, color='#2b6cb0'){
      const ring=new THREE.Mesh(new THREE.RingGeometry(0.02,0.04,48), new THREE.MeshBasicMaterial({color,transparent:true,opacity:0.95,side:THREE.DoubleSide,depthTest:false}));
      const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), normal.clone().normalize()); ring.quaternion.copy(q);
      ring.position.copy(pos).add(normal.clone().multiplyScalar(0.0005));
      ring.userData.birth=performance.now(); ring.userData.duration=PING_DURATION; ring.userData.isPing=true; ring.scale.set(0.3,0.3,0.3);
      modelRoot.add(ring); pings.push(ring); if(pings.length>MAX_PINGS){ const old=pings.shift(); modelRoot.remove(old); }
    }

    let downPos=null, downTime=0;
    canvas.addEventListener('pointerdown',(e)=>{ downPos=[e.clientX,e.clientY]; downTime=performance.now(); });
    canvas.addEventListener('pointerup',(e)=>{
      if(!downPos) return; const dt=performance.now()-downTime; const dx=e.clientX-downPos[0], dy=e.clientY-downPos[1]; downPos=null;
      if(dt>350||Math.hypot(dx,dy)>5) return;
      const rect=renderer.domElement.getBoundingClientRect();
      pointer.x=((e.clientX-rect.left)/rect.width)*2-1; pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(pointer, camera);
      const targets=modelRoot.children.filter(o=>!(o.userData&&o.userData.isPing));
      const hits=raycaster.intersectObjects(targets,true); if(!hits.length) return;
      const hit=hits[0]; const pos=hit.point.clone();
      const normal=hit.face? hit.face.normal.clone().transformDirection(hit.object.matrixWorld) : new THREE.Vector3(0,1,0);
      createPing(pos, normal, params.edgeColor); playPing(0.25,920);
      if(!applyingRemote){ socket.emit('clickPing',{ pos:{x:pos.x,y:pos.y,z:pos.z}, normal:{x:normal.x,y:normal.y,z:normal.z}, color:params.edgeColor }); }
    });

    socket.on('clickPing',(data)=>{
      const pos=new THREE.Vector3(data.pos.x,data.pos.y,data.pos.z);
      const normal=new THREE.Vector3(data.normal.x,data.normal.y,data.normal.z).normalize();
      createPing(pos, normal, data.color||'#2b6cb0');
      playPing(0.16,820);
    });

    // 수신(sync)
    socket.on("syncState",(data)=>{
      applyingRemote=true;
      if(data.params){
        const before=JSON.stringify(params);
        Object.assign(params, data.params);
        panelMat.color.set(params.color); edgeMat.color.set(params.edgeColor);
        ui.w.value=params.w; ui.h.value=params.h; ui.rows.value=params.rows; ui.cols.value=params.cols;
        depthPicker.centerOn(params.d,false); thickPicker.centerOn(params.t,false);
        renderPalette(params.scheme); updateBadges();
        applyDoorAngles(params.door.angleL, params.door.angleR);
        if(before!==JSON.stringify(params)) buildShelf(params);
        updateQuoteHUD();
      }
      if(data.camPos) camera.position.set(data.camPos.x,data.camPos.y,data.camPos.z);
      if(data.camQuat) camera.quaternion.set(data.camQuat.x,data.camQuat.y,data.camQuat.z,data.camQuat.w);
      if(typeof data.camZoom==="number"){ camera.zoom=data.camZoom; camera.updateProjectionMatrix(); }
      if(data.target) controls.target.set(data.target.x,data.target.y,data.target.z);
      controls.update(); applyingRemote=false;
    });

    // 카메라 자동 프레이밍
    let camTween=null;
    function autoFrameBothTween(fraction=0.6, duration=350){
      const box=new THREE.Box3().setFromObject(modelRoot);
      if(!isFinite(box.min.x)||!isFinite(box.max.x)) return;
      const size=new THREE.Vector3(); box.getSize(size); const center=new THREE.Vector3(); box.getCenter(center);
      const fovY=THREE.MathUtils.degToRad(camera.fov), fovX=2*Math.atan(Math.tan(fovY/2)*camera.aspect);
      const frac=Math.max(0.05,Math.min(0.95,fraction));
      const distX=size.x/(2*Math.tan(fovX/2)*frac), distY=size.y/(2*Math.tan(fovY/2)*frac), dist=Math.max(distX,distY);
      const dirV=camera.position.clone().sub(controls.target).normalize(); if(!isFinite(dirV.length())||dirV.length()<1e-6) dirV.set(1,1,1).normalize();
      camTween={ start:performance.now(), dur:duration, fromPos:camera.position.clone(), toPos:center.clone().add(dirV.multiplyScalar(dist)), fromTgt:controls.target.clone(), toTgt:center };
    }

    // 초기 빌드
    function initAll(){
      buildShelf(params); updateBadges(); updateQuoteHUD();
      applyRoleMode();
      if (ROLE === 'pro' && !EMBED) setMobilePreviewSrc();
    }
    initAll();

    (function animate(){
      requestAnimationFrame(animate);
      curDoorL += (targetDoorL - curDoorL) * 0.18;
      curDoorR += (targetDoorR - curDoorR) * 0.18;
      if(doorPivots.left)  doorPivots.left.rotation.y  = curDoorL;
      if(doorPivots.right) doorPivots.right.rotation.y = curDoorR;

      if(camTween){
        const now=performance.now(); let t=(now-camTween.start)/camTween.dur;
        if(t>=1){ camera.position.copy(camTween.toPos); controls.target.copy(camTween.toTgt); camTween=null; }
        else{ const e=t*t*(3-2*t); camera.position.lerpVectors(camTween.fromPos,camTween.toPos,e); controls.target.lerpVectors(camTween.fromTgt,camTween.toTgt,e); }
        camera.updateProjectionMatrix(); controls.update(); sendCamera();
      }else{ controls.update(); }

      const now=performance.now();
      for(let i=pings.length-1;i>=0;i--){ const m=pings[i]; const tt=(now-m.userData.birth)/m.userData.duration;
        if(tt>=1){ modelRoot.remove(m); pings.splice(i,1); continue; }
        const ease=tt*tt*(3-2*tt); const s=0.3 + ease*1.7; m.scale.set(s,s,s); m.material.opacity=0.95*(1-ease);
      }

      renderer.render(scene,camera); labelRenderer.render(scene,camera);
    })();

    // ===== 책장 생성 =====
    function buildShelf(p){
      clearGroup(modelRoot);

      const W=cm(p.w), H=cm(p.h), D=mm(p.d), T=mm(p.t);
      const rows=Math.max(1,Math.floor(p.rows));
      const cols=Math.max(1,Math.floor(p.cols));

      // 외곽
      panelWithEdge(T,H,D, -W/2+T/2,0,0,true);
      panelWithEdge(T,H,D,  W/2-T/2,0,0,true);
      panelWithEdge(W-2*T,T,D, 0, H/2-T/2,0,true);
      panelWithEdge(W-2*T,T,D, 0,-H/2+T/2,0,true);

      const backT = Math.max(T, D*0.02);
      panelWithEdge(W-2*T, H-2*T, backT, 0,0,-D/2+backT/2, false);

      const drawerLayout = computeDrawerLayout(p);

      const innerH = H-2*T;
      const rowStep = innerH/rows;
      const threshold = drawerLayout ? (drawerLayout.yTop + mm(2)) : (-Infinity);
      for(let i=1;i<rows;i++){
        const y = -H/2 + T + i*rowStep;
        if(y <= threshold) continue;
        panelWithEdge(W-2*T, T, D, 0, y, 0, true);
      }

      if(!(p.drawers && p.drawers.enabled)){
        const innerW=W-2*T;
        const colStep=innerW/cols;
        for(let j=1;j<cols;j++){
          const x = -W/2 + T + j*colStep;
          panelWithEdge(T, H-2*T, D, x, 0, 0, true);
        }
      }

      buildDoors(p);
      buildDrawers(drawerLayout);

      controls.target.set(0,0,0); controls.update();
      updateDimensions(p);
      updateEnvironment();
      tuneShadowCamera();
    }
  </script>
</body>
</html>
